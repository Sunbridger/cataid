# 🔍 通知未送达深度诊断指南

## 当前状态
- ✅ RLS 已禁用
- ✅ Realtime 已启用
- ✅ 数据库中有通知记录
- ❌ 前端未收到通知

---

## 📋 诊断步骤

### 步骤 1: 检查浏览器 Console 日志

1. 打开浏览器开发者工具 (F12)
2. 切换到 **Console** 标签
3. 刷新页面 (F5)
4. 查找以下日志:

#### 预期看到的日志:
```
[Notification] Setting up Realtime subscription for user: xxx
[Notification] Subscription status: SUBSCRIBED
[Notification] ✅ Successfully subscribed to notifications
```

#### 如果看到错误:
```
❌ [Notification] Supabase client not initialized
   → 检查环境变量是否正确

❌ [Notification] No user ID, skipping subscription
   → 用户未登录或登录状态丢失

❌ [Notification] ❌ Channel error
   → Supabase 连接问题或权限问题

❌ [Notification] ❌ Subscription timed out
   → 网络问题或 Supabase 服务问题
```

---

### 步骤 2: 验证用户登录状态

在浏览器 Console 中执行:

```javascript
// 检查用户是否登录
console.log('User:', JSON.parse(localStorage.getItem('user') || '{}'));

// 检查环境变量
console.log('Supabase URL:', import.meta.env.VITE_SUPABASE_URL);
console.log('Supabase Key:', import.meta.env.VITE_SUPABASE_ANON_KEY ? '已配置' : '未配置');
```

---

### 步骤 3: 检查数据库中的用户 ID

在 Supabase SQL Editor 执行:

```sql
-- 查找"七彩"的用户信息
SELECT id, nickname, phone, email
FROM users
WHERE nickname = '七彩';

-- 查找"小憩"的用户信息
SELECT id, nickname, phone, email
FROM users
WHERE nickname = '小憩';
```

**记下"七彩"的 user_id**，后面会用到。

---

### 步骤 4: 检查评论的 user_id

```sql
-- 查看最近的评论，检查 user_id 是否正确
SELECT
  id,
  nickname,
  user_id,
  parent_id,
  content,
  created_at
FROM comments
WHERE nickname IN ('七彩', '小憩')
ORDER BY created_at DESC
LIMIT 10;
```

⚠️ **关键检查**:
- "七彩"的评论是否有 `user_id`？
- "小憩"回复时，`parent_id` 是否指向"七彩"的评论？

---

### 步骤 5: 检查通知记录

```sql
-- 查看为"七彩"创建的通知
SELECT
  n.id,
  n.user_id,
  u.nickname,
  n.type,
  n.title,
  n.content,
  n.created_at
FROM notifications n
LEFT JOIN users u ON n.user_id = u.id
WHERE u.nickname = '七彩'
ORDER BY n.created_at DESC
LIMIT 5;
```

**检查点**:
- `user_id` 是否与"七彩"的 user_id 一致？
- `type` 是否为 `comment_reply`？
- `created_at` 是否是最近的时间？

---

### 步骤 6: 手动测试 Realtime

在 Supabase SQL Editor 手动插入一条测试通知:

```sql
-- 替换 'USER_ID_HERE' 为"七彩"的实际 user_id
INSERT INTO notifications (user_id, type, title, content, related_type)
VALUES (
  'USER_ID_HERE',  -- 替换为七彩的 user_id
  'test',
  '测试通知',
  '这是一条手动插入的测试通知',
  'test'
);
```

**执行后立即查看**:
- 浏览器 Console 是否有 `[Notification] Received new notification` 日志？
- 导航栏的通知图标是否显示未读数量？

---

## 🐛 常见问题诊断

### 问题 1: Console 显示 "Supabase client not initialized"

**原因**: 环境变量未正确配置

**解决**:
```bash
# 检查 .env.local
cat .env.local | grep VITE_SUPABASE

# 应该看到:
# VITE_SUPABASE_URL=https://vljwyjfdpfjmjidbfmcs.supabase.co
# VITE_SUPABASE_ANON_KEY=eyJhbGci...
```

**如果没有，重新配置并重启服务器**:
```bash
npm run dev
```

---

### 问题 2: Console 显示 "No user ID"

**原因**: 用户未登录或登录状态丢失

**解决**:
1. 检查 localStorage 中是否有用户信息
2. 重新登录
3. 确保 UserContext 正确传递用户信息

---

### 问题 3: 订阅成功但收不到消息

**原因**: 可能的原因有多个

**检查**:
1. **user_id 不匹配**
   ```sql
   -- 检查通知的 user_id 是否与登录用户一致
   SELECT user_id FROM notifications WHERE id = 'notification_id';
   ```

2. **评论的 user_id 为空**
   ```sql
   -- 检查评论是否有 user_id
   SELECT id, nickname, user_id FROM comments WHERE nickname = '七彩';
   ```

   如果 `user_id` 为 NULL，通知不会创建！

3. **Realtime filter 不匹配**
   - 订阅 filter: `user_id=eq.${user.id}`
   - 通知的 `user_id` 必须完全匹配

---

### 问题 4: 评论时 user_id 为空

**原因**: 评论时未传递 userId

**检查代码**:
```typescript
// 在提交评论的地方，确保传递了 userId
const comment = {
  catId: '...',
  userId: user?.id,  // ← 确保这个值存在
  nickname: user?.nickname,
  content: '...',
  // ...
};
```

---

## 🔧 临时解决方案

如果 Realtime 实在不工作，可以使用轮询方案:

```typescript
// 在 NotificationContext.tsx 中添加轮询
useEffect(() => {
  if (!user?.id) return;

  // 每 10 秒刷新一次未读数量
  const interval = setInterval(() => {
    refreshUnreadCount();
  }, 10000);

  return () => clearInterval(interval);
}, [user?.id, refreshUnreadCount]);
```

---

## 📊 完整检查清单

执行以下检查，找出问题所在:

- [ ] 浏览器 Console 显示 "Successfully subscribed"
- [ ] 环境变量 VITE_SUPABASE_URL 已配置
- [ ] 环境变量 VITE_SUPABASE_ANON_KEY 已配置
- [ ] 用户已登录且有 user_id
- [ ] "七彩"的评论有 user_id
- [ ] 通知记录的 user_id 与"七彩"的 user_id 一致
- [ ] 手动插入测试通知能收到
- [ ] RLS 已禁用 (rowsecurity = false)
- [ ] Realtime 已启用 (notifications 在 supabase_realtime 发布中)

---

## 🎯 下一步行动

1. **立即执行**: 打开浏览器 Console，查看日志
2. **记录信息**: 截图 Console 中的所有日志
3. **执行 SQL**: 运行上面的诊断 SQL
4. **测试**: 手动插入测试通知

完成后，根据日志和 SQL 结果，我们可以精确定位问题。
